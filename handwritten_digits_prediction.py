# -*- coding: utf-8 -*-
"""Handwritten Digits Prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16D31ul85_3Gl-ckIs8lRPQ6Hv9HiAPh9

#Handwritten Digit Recognition

##Step 1: Data Preparation

- Load the MNIST dataset, which consists of images of handwritten digits (0-9).
- Normalize the pixel values of the images to be in the range [0, 1].
- Reshape the images to match the input requirements of a CNN (e.g., (28, 28, 1)).
- One-hot encode the labels to convert them into binary vectors.

###Importing the necessary Libraries
"""

# Import necessary libraries
import numpy as np
import matplotlib.pyplot as plt
from keras.datasets import mnist
from keras import layers
from keras import models
from keras.utils import to_categorical

"""###Loading the dataset"""

# Load the MNIST dataset
(train_images, train_labels), (test_images, test_labels) = mnist.load_data()

# Normalize and reshape the data
train_images = train_images.reshape((60000, 28, 28, 1))
train_images = train_images.astype('float32') / 255

test_images = test_images.reshape((10000, 28, 28, 1))
test_images = test_images.astype('float32') / 255

"""###Applying One-Hot Encoding"""

# One-hot encode the labels
train_labels = to_categorical(train_labels)
test_labels = to_categorical(test_labels)

print("Data preparation complete. Ready for training.")

"""##Step 2: Build a Convolutional Neural Network (CNN) Model

- Create a CNN model with convolutional layers (Conv2D) and max-pooling layers.
- Use ReLU activation functions for the convolutional layers.
- Add fully connected (dense) layers with ReLU activation functions for classification.
- The output layer has 10 units (one for each digit) with a softmax activation for classification.
- Compile the model using an optimizer (e.g., Adam) and the categorical cross-entropy loss function, suitable for multi-class classification.

"""

# Create a CNN model
model = models.Sequential()
model.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)))
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Conv2D(64, (3, 3), activation='relu'))
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Conv2D(64, (3, 3), activation='relu'))
model.add(layers.Flatten())
model.add(layers.Dense(64, activation='relu'))
model.add(layers.Dense(10, activation='softmax'))

"""###Compiling the Model"""

# Compile the model
model.compile(optimizer='adam',
              loss='categorical_crossentropy',
              metrics=['accuracy'])

model.summary()
print("CNN model created. Ready for training.")

"""##Step 3: Train the CNN Model

- Train the model on the training dataset using the `fit` method.
- Specify the number of training epochs, batch size, and validation split for monitoring the model's performance.
- During training, the model's weights are updated to minimize the categorical cross-entropy loss on the training data.

"""

# Train the model
history = model.fit(train_images, train_labels, epochs=5, batch_size=64, validation_split=0.2)

# Evaluate the model on the test data
test_loss, test_acc = model.evaluate(test_images, test_labels)

print(f"Test accuracy: {test_acc * 100:.2f}%")

"""##Step 4: Make Predictions

- Use the trained model to make predictions on new handwritten digit images.
- Convert the model's predictions, which are probability distributions over classes, into digit labels by selecting the class with the highest probability (argmax).
- Display the test images along with their predicted labels for visual inspection.

"""

# Make predictions on a few test images
predictions = model.predict(test_images[:10])

# Convert predictions to digit labels
predicted_labels = np.argmax(predictions, axis=1)

"""###Function for Plotting the graph"""

# Display the predicted labels and corresponding images
for i in range(10):
    plt.subplot(1, 10, i + 1)
    plt.imshow(test_images[i].reshape(28, 28), cmap='gray')
    plt.title(f"{predicted_labels[i]}")
    plt.axis('off')

plt.show()

"""##Step 5: Save and Deploy the Model

- Save the trained model to a file, often in the format of a ".h5" file.
- This saved model can be loaded and used for digit recognition in other applications or integrated into a web or mobile application.

"""

# Save the trained model to a file
model.save('mnist_digit_recognition_model.h5')

print("Model saved as 'mnist_digit_recognition_model.h5'.")